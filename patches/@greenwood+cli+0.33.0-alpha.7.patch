diff --git a/node_modules/@greenwood/cli/src/lib/execute-route-module.js b/node_modules/@greenwood/cli/src/lib/execute-route-module.js
index 43f9534..c21663b 100644
--- a/node_modules/@greenwood/cli/src/lib/execute-route-module.js
+++ b/node_modules/@greenwood/cli/src/lib/execute-route-module.js
@@ -8,6 +8,7 @@ async function executeRouteModule({
   htmlContents = null,
   scripts = [],
   request,
+  props,
   contentOptions = {},
 }) {
   const data = {
@@ -23,6 +24,7 @@ async function executeRouteModule({
 
     data.html = html;
   } else {
+    console.log({ props });
     const module = await import(moduleUrl).then((module) => module);
     const { body, layout, frontmatter } = contentOptions;
     const {
@@ -35,10 +37,15 @@ async function executeRouteModule({
 
     if (body) {
       if (module.default) {
-        const { html } = await renderToString(new URL(moduleUrl), false, { request, compilation });
+        const { html } = await renderToString(new URL(moduleUrl), false, {
+          request,
+          compilation,
+          props,
+        });
 
         data.body = html;
       } else if (getBody) {
+        // TODO do we need to pass props here too?
         data.body = await getBody(compilation, page, request);
       }
     }
diff --git a/node_modules/@greenwood/cli/src/lib/ssr-route-worker.js b/node_modules/@greenwood/cli/src/lib/ssr-route-worker.js
index b10d823..df15559 100644
--- a/node_modules/@greenwood/cli/src/lib/ssr-route-worker.js
+++ b/node_modules/@greenwood/cli/src/lib/ssr-route-worker.js
@@ -11,6 +11,7 @@ async function executeModule({
   scripts = "[]",
   request,
   contentOptions = "{}",
+  props,
 }) {
   const { executeRouteModule } = await import(executeModuleUrl);
   const data = await executeRouteModule({
@@ -22,6 +23,7 @@ async function executeModule({
     scripts: JSON.parse(scripts),
     request,
     contentOptions: JSON.parse(contentOptions),
+    props,
   });
 
   parentPort.postMessage(data);
diff --git a/node_modules/@greenwood/cli/src/lifecycles/bundle.js b/node_modules/@greenwood/cli/src/lifecycles/bundle.js
index 6149e09..4efe830 100644
--- a/node_modules/@greenwood/cli/src/lifecycles/bundle.js
+++ b/node_modules/@greenwood/cli/src/lifecycles/bundle.js
@@ -361,7 +361,7 @@ async function bundleSsrPages(compilation, optimizePlugins) {
 
         const moduleUrl = new URL('${relativeDepth}${pagesPathDiff}${pagePath.replace("./", "")}', import.meta.url);
 
-        export async function handler(request) {
+        export async function handler(request, props) {
           const compilation = JSON.parse(\`${JSON.stringify({
             ...compilation,
             graph: pruneGraph(compilation.graph),
@@ -371,7 +371,7 @@ async function bundleSsrPages(compilation, optimizePlugins) {
           const page = JSON.parse(\`${JSON.stringify(pruneGraph([page])[0])
             .replace(/\\"/g, "&quote")
             .replace(/\\n/g, "")}\`);
-          const data = await executeRouteModule({ moduleUrl, compilation, page, request, contentOptions: { body: true } });
+          const data = await executeRouteModule({ moduleUrl, compilation, page, request, contentOptions: { body: true }, props });
           let staticHtml = \`${staticHtml}\`;
 
           if (data.body) {
diff --git a/node_modules/@greenwood/cli/src/lifecycles/graph.js b/node_modules/@greenwood/cli/src/lifecycles/graph.js
index d6bdf90..5f6d3e1 100644
--- a/node_modules/@greenwood/cli/src/lifecycles/graph.js
+++ b/node_modules/@greenwood/cli/src/lifecycles/graph.js
@@ -109,6 +109,20 @@ const generateGraph = async (compilation) => {
           // TODO should API routes be run in isolation mode like SSR pages?
           const { isolation } = await import(filenameUrl).then((module) => module);
 
+          // TODO would be nice to use new URLPattern({ pathname: route }); // /users/[id]/
+          // TODO how to handle brackets for thing like generated IDs and whatnot for page metadata
+          const pattern = new URLPattern({ pathname: route.replace("[", ":").replace("]", "") });
+          // console.log({ pattern });
+          // console.log({ route, relativePagePath }, pattern.test("https://example.com/users/123/")); // true
+          const dynamicSegments = pattern.test(`https://example.com${basePath}${route}`);
+          // console.log({ dynamicSegments });
+          // console.log('segments', pattern.exec("https://example.com/users/123/"))
+          const segmentKey = relativePagePath
+            .split("/")
+            [relativePagePath.split("/").length - 1].replace(extension, "")
+            .replace("[", "")
+            .replace("]", "");
+
           /*
            * API Properties (per route)
            *----------------------
@@ -126,6 +140,9 @@ const generateGraph = async (compilation) => {
             outputHref: new URL(relativePagePath, outputDir).href.replace(extension, ".js"),
             route: `${basePath}${route}`,
             isolation,
+            segment: dynamicSegments
+              ? { key: segmentKey, pathname: route.replace("[", ":").replace("]", "") }
+              : null,
           });
         } else if (isPage) {
           let root = filename.split("/")[filename.split("/").length - 1].replace(extension, "");
@@ -272,8 +289,26 @@ const generateGraph = async (compilation) => {
            * hydration: if this page needs hydration support
            * servePage: signal that this is a custom page file type (static | dynamic)
            */
+
+          // TODO would be nice to use new URLPattern({ pathname: route }); // /users/[id]/
+          // TODO how to handle brackets for thing like generated IDs and whatnot for page metadata
+          const pattern = new URLPattern({ pathname: route.replace("[", ":").replace("]", "") });
+          // console.log({ pattern });
+          // console.log({ route, relativePagePath }, pattern.test("https://example.com/users/123/")); // true
+          const dynamicSegments = pattern.test(`https://example.com${basePath}${route}`);
+          // console.log({ dynamicSegments });
+          // console.log('segments', pattern.exec("https://example.com/users/123/"))
+          const segmentKey = relativePagePath
+            .split("/")
+            [relativePagePath.split("/").length - 1].replace(extension, "")
+            .replace("[", "")
+            .replace("]", "");
+
+          // TODO figure out best filename output naming convention for these special [id] routes
           const page = {
-            id: decodeURIComponent(getIdFromRelativePathPath(relativePagePath, extension)),
+            id: decodeURIComponent(getIdFromRelativePathPath(relativePagePath, extension))
+              .replace("[", "-")
+              .replace("]", "-"),
             label: decodeURIComponent(label),
             title: title ? decodeURIComponent(title) : title,
             route: `${basePath}${route}`,
@@ -291,6 +326,9 @@ const generateGraph = async (compilation) => {
             isolation,
             hydration,
             servePage: isCustom,
+            segment: dynamicSegments
+              ? { key: segmentKey, pathname: route.replace("[", ":").replace("]", "") }
+              : null,
           };
 
           pages.push(page);
diff --git a/node_modules/@greenwood/cli/src/lifecycles/serve.js b/node_modules/@greenwood/cli/src/lifecycles/serve.js
index ea5a171..26a77e3 100644
--- a/node_modules/@greenwood/cli/src/lifecycles/serve.js
+++ b/node_modules/@greenwood/cli/src/lifecycles/serve.js
@@ -348,12 +348,39 @@ async function getHybridServer(compilation) {
   app.use(async (ctx) => {
     try {
       const url = new URL(`http://localhost:${config.port}${ctx.url}`);
+      const { pathname } = url;
       const matchingRoute = graph.find((node) => node.route === url.pathname) || { data: {} };
       const isApiRoute = manifest.apis.has(url.pathname);
       const request = transformKoaRequestIntoStandardRequest(url, ctx.request);
+      const matchingRouteWithSegment =
+        compilation.graph.find((node) => {
+          return (
+            pathname !== "/404/" &&
+            node.segment &&
+            new URLPattern({ pathname: node.segment.pathname }).test(
+              `https://example.com${pathname}`,
+            )
+          );
+        }) || {};
 
-      if (!config.prerender && matchingRoute.isSSR && !matchingRoute.prerender) {
-        const entryPointUrl = new URL(matchingRoute.outputHref);
+      if (
+        !config.prerender &&
+        (matchingRoute.isSSR || matchingRouteWithSegment.isSSR) &&
+        !matchingRoute.prerender
+      ) {
+        console.log("SERVE", { matchingRouteWithSegment });
+        const entryPointUrl = new URL(
+          matchingRoute?.outputHref ?? matchingRouteWithSegment.outputHref,
+        );
+        // TODO shouldn't we be able to get this from segment.key?
+        const props =
+          matchingRouteWithSegment && matchingRouteWithSegment.segment
+            ? new URLPattern({ pathname: matchingRouteWithSegment.segment.pathname }).exec(
+                `https://example.com${pathname}`,
+              ).pathname.groups
+            : undefined;
+
+        console.log("PROPS to send", { props });
         let html;
 
         if (matchingRoute.isolation || isolationMode) {
@@ -381,12 +408,16 @@ async function getHybridServer(compilation) {
               routeModuleUrl: entryPointUrl.href,
               request,
               compilation: JSON.stringify(compilation),
+              props,
             });
           });
         } else {
           // @ts-expect-error see https://github.com/microsoft/TypeScript/issues/42866
           const { handler } = await import(entryPointUrl);
-          const response = await handler(request, compilation);
+          // we used to pass compilation here???
+          // TODO we used to pass compilation here???
+          // const response = await handler(request, compilation);
+          const response = await handler(request, props);
 
           html = Readable.from(response.body);
         }
diff --git a/node_modules/@greenwood/cli/src/plugins/resource/plugin-api-routes.js b/node_modules/@greenwood/cli/src/plugins/resource/plugin-api-routes.js
index 4e2a2e8..5b4ff16 100644
--- a/node_modules/@greenwood/cli/src/plugins/resource/plugin-api-routes.js
+++ b/node_modules/@greenwood/cli/src/plugins/resource/plugin-api-routes.js
@@ -14,12 +14,28 @@ class ApiRoutesResource {
 
   async shouldServe(url) {
     const { protocol, pathname } = url;
+    const { basePath } = this.compilation.config;
 
-    return protocol.startsWith("http") && this.compilation.manifest.apis.has(pathname);
+    if(!protocol.startsWith("http") || !pathname.startsWith(`${basePath}/api/`)) {
+      return;
+    }
+
+    const matchingRouteWithSegment = Array.from(this.compilation.manifest.apis.keys()).find(key => {
+      const route = this.compilation.manifest.apis.get(key);
+      return route.segment && new URLPattern({ pathname: `${route.segment.pathname}*` }).test(`https://example.com${pathname}`)
+    })
+    
+    return matchingRouteWithSegment || this.compilation.manifest.apis.has(pathname);
   }
 
   async serve(url, request) {
-    const api = this.compilation.manifest.apis.get(url.pathname);
+    const { pathname } = url;
+    const matchingRouteWithSegment = Array.from(this.compilation.manifest.apis.keys()).find(key => {
+      const route = this.compilation.manifest.apis.get(key);
+      return route.segment && new URLPattern({ pathname: `${route.segment.pathname}*` }).test(`https://example.com${pathname}`)
+    })
+    
+    const api = this.compilation.manifest.apis.get(matchingRouteWithSegment ?? url.pathname);
     const apiUrl = new URL(api.pageHref);
     const href = apiUrl.href;
 
diff --git a/node_modules/@greenwood/cli/src/plugins/resource/plugin-standard-html.js b/node_modules/@greenwood/cli/src/plugins/resource/plugin-standard-html.js
index 7eeca5f..c56d31d 100644
--- a/node_modules/@greenwood/cli/src/plugins/resource/plugin-standard-html.js
+++ b/node_modules/@greenwood/cli/src/plugins/resource/plugin-standard-html.js
@@ -27,10 +27,21 @@ class StandardHtmlResource {
     const { protocol, pathname } = url;
     const hasMatchingPageRoute = this.compilation.graph.find((node) => node.route === pathname);
     const isSPA = this.compilation.graph.find((node) => node.isSPA) && pathname.indexOf(".") < 0;
+    // TODO consolidate with other graph matching logic
+    const matchingRouteWithSegment = this.compilation.graph.find((node) => {
+      return (
+        (pathname !== "/404/") !== "/404/" &&
+        node.segment &&
+        new URLPattern({ pathname: node.segment.pathname }).test(`https://example.com${pathname}`)
+      );
+    });
 
+    // console.log({ matchingRouteWithSegment });
     return (
       protocol.startsWith("http") &&
-      (hasMatchingPageRoute || (isSPA && request.headers.get("Accept").indexOf("text/html") >= 0))
+      (hasMatchingPageRoute ||
+        matchingRouteWithSegment ||
+        (isSPA && request.headers.get("Accept").indexOf("text/html") >= 0))
     );
   }
 
@@ -40,6 +51,15 @@ class StandardHtmlResource {
     const { pathname } = url;
     const isSpaRoute = this.compilation.graph.find((node) => node.isSPA);
     const matchingRoute = this.compilation.graph.find((node) => node.route === pathname) || {};
+    const matchingRouteWithSegment =
+      this.compilation.graph.find((node) => {
+        // TODO better way to handle 404?
+        return (
+          pathname !== "/404/" &&
+          node.segment &&
+          new URLPattern({ pathname: node.segment.pathname }).test(`https://example.com${pathname}`)
+        );
+      }) || {};
     const { pageHref } = matchingRoute;
     const filePath =
       !matchingRoute.external && pageHref
@@ -95,12 +115,21 @@ class StandardHtmlResource {
       const transformed = await customPageFormatPlugins[0].serve(new URL(pageHref));
 
       body = await transformed.text();
-    } else if (matchingRoute.isSSR) {
-      const routeModuleLocationUrl = new URL(pageHref);
+    } else if (matchingRoute.isSSR || matchingRouteWithSegment.isSSR) {
+      const routeModuleLocationUrl = new URL(pageHref ?? matchingRouteWithSegment.pageHref);
       const routeWorkerUrl = this.compilation.config.plugins
         .find((plugin) => plugin.type === "renderer")
         .provider().executeModuleUrl;
       const req = await requestAsObject(request);
+      console.log("html plugin", { matchingRouteWithSegment });
+      // TODO shouldn't we be able to get this from segment.key?
+      const props =
+        matchingRouteWithSegment && matchingRouteWithSegment.segment
+          ? new URLPattern({ pathname: matchingRouteWithSegment.segment.pathname }).exec(
+              `https://example.com${pathname}`,
+            ).pathname.groups
+          : undefined;
+      console.log("HTML Plugin PROPS to send", { props });
 
       await new Promise((resolve, reject) => {
         const worker = new Worker(new URL("../../lib/ssr-route-worker.js", import.meta.url));
@@ -124,10 +153,12 @@ class StandardHtmlResource {
           moduleUrl: routeModuleLocationUrl.href,
           compilation: JSON.stringify(this.compilation),
           page: JSON.stringify(matchingRoute),
+          // TODO consolidate all constructor props into a single object?
           request: req,
           contentOptions: JSON.stringify({
             body: true,
           }),
+          props,
         });
       });
     }
